##12.1链表的递归表述
好像之前自己提前写了一遍,在这里不多废话了.  
```
typedef struct cellT{
  char ch;
  struct cellT *link;
}cellT;
```
上述结构包含一个对相同类型的另一个值的引用.  
以这种方式定义的类型称为**递归类型**.  
介绍一个概念:  
进制用户对其底层表示进行任何修改的抽象类型称为**不变类型**.  
不变量类型的重要性:  
1. 不变类型通常具有简单的内部结构  
2. 在不变量诶行中,可以使用空指针来指明空抽象值.  
3. 使用不变类型通常使得程序的行为更易理解.  
4. 不变类型允许数据的内部共享.  

(个人认为,不变类型就是你自己写了很多的函数对结构类型进行操作,比如创建释放添加删除等等,从而不暴露底层实现,用户不可知是如何实现,只是知道怎么用,就好比java中的集合类, 看着api文档查相关方法就可以搞定各种问题)  

###12.2.4 不变类型间的内部共享
举个例子:  
list1: A,B,C 有三个元素  
list2: D,E 有两个元素  
现在通过一个函数list = ListConcat(list1,list2);把他们链接起来  
这时候list:A,B,C,D,E  
如果改变list2为:D,F  
那么list也做出相应改变:A,B,C,D,F  
所以书上的相应代码中.并没有释放list的相关函数.以防止发生错误.  
为了使其正常工作,如listADT抽象这样使用内部共享技术的抽象依靠内存分配系统来发现可以重新使用的内存.  
利用计算机来识别不再使用的内存并进行回收以供再次分配的技术称为**垃圾回收**.  

(PS:上述链表内部共享,只是因为在ListConcat执行时,传入的都是地址,传出的也是原地址,如果是创建一个新的链表,进行链接再返回,估计就不会出现上述状况,所以应该是函数内部实现的问题,具体想要什么样的操作应该看你是如何实现,我觉得这个问题没有必要深究.至于垃圾回收机制,嗯,书上没有,我也没有了解过,改天去看看java中的垃圾回收机制再来接受)  

##12.3使用链表表示最大整数
如果要表示一个很大的整数,大到已经无法用C语言中的整型类型存储这样的整数了.(所存数字的大小与它类型所占字节长度有关)  
解除硬件带来的极限的最简单方法是将大整数打散成小块,每个小块存储到一个单独的内存空间.这种技术称为**多精度算法**.  
多精度算法即可以以硬件实现,也可以以软件实现,以软件的方式实现,需要设计一个提供对整数(存储在一系列小块中)的标准算数操作包.此包提供了编程人员所说的**任意精度算法**,从而使经度不再受任何的限制.  

##12.3.2表示类型bigIntADT  
大致思想就是, 一个块,存一个数,即一个链表的节点,存一位.  
存储顺序按照逆序比较方便,比如1789,链表中即 9->8->7->1  
至于实现:  
加减比较简单,相应的位置进行加减,然后把数字转换为字符串进行输出.  
乘法:比如实现 189*178 = 189*8+189*80+189*100  
可以用递归的方式: 189*8+189*170  
按位进行乘,然后再加起来.实现时,只要按照递归的次数,在乘的结果后面加上相应个数的0,就可以表示乘以80,100了.  
然而书上并没有介绍除法(o(∩_∩)o),通过看相关博客,好像大多数的算法都是慢慢试出来的,类似小学时学的除法,从高位开始,慢慢的试商,从9开始试,9乘以除数,和被除数比大小,如果比被除数大,就拿8试,然后一直试到第一个比被除数小的数,做减法,然后除数右移一位,一直算下去.大致思路就是这样.  




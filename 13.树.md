##13.1树的定义
本章将介绍一种使用指针来模拟层次关系的数据结构---**树**,它是由一个具有一下特征的称为**节点**的项的集合所定义的:  
1. 只要树中有节点,必定有一个称为**根**的节点,它是最顶层.  
2. 其他节点通过唯一确定的下降路径链接到根.  
![image](https://github.com/nightriain/c/blob/master/tree.jpg)  
###13.1.1描述树的术语
如上图所示:
节点1 为 **根**  
节点 8 9 10 6 7,这些没有孩子的节点,称为 **叶**  
即不是根节点,也不是叶节点,称为**内部节点**,如 2 3  
节点2 和节点3 是节点1的**孩子**  
节点2 和节点3 是**兄弟**  
树的**高度**定义为,从根到叶的最长路径的长度,从1到8最远,树的高度是4.  
###13.1.2树的递归特性
从树中选取一个节点及其子孙构成的树称为原树的**子树**.  
树中的每个节点都可以看成是以它自己为根的 子树的根.  
###13.1.3用 C语言表示树  
结构体的定义:  
```
typedef struct familyNodeT{
    string name;
    struct familyNodeT *children[MaxChildren];  //包含了一个指向自身的指针数组
}familyNodeT,*familyTreeT;
```
 
##13.2二叉搜索树
树的一个最终要的子类是**二叉树**,具有如下特征:  
1. 树中的每个节点至多有两个孩子.  
2. 除了根以外的其他节点不是父节点的左孩子,就是右孩子.  
二叉树的节点所具有的几何关系使得使用二叉树来表示数据的有序集合十分方便.  
通常的应用使用一种称为**二叉搜索树**的特殊二叉树,它由以下特性定义:  
1. 每个节点包含(可能有其他数据)一个称为"键"的特殊值,该值定义了节点的顺序.  
2. 键具有**唯一性**,在树中键不能出现多于一次.  
3. 在树中的每一个节点,键值必须大于其子树中左孩子的所有键,小于子树中有孩子的所有键.  

简单来讲.一个树上的键不能有重复的值,和之前的符号表有些类似,相同的键只能存在一个.节点要大于它的左孩子,小于右孩子.  
###13.2.2在二叉搜索树中查找节点  
由于树是递归结构,很容以递归的形式对该搜索算法进行编码.  
InsertNode代码稍微有些复杂,难点是InsertNode必须能够通过增加一个新建来改变二叉搜索树的值.  
在C语言中,函数不能改变其参数的值,为了绕过这个限制,InsertNode必须使用引用调用,而不是像FindNode中那样接受一个treeT作为参数,InsertNode需要接收一个指向treeT的指针.因此它的原型如下:  
void InsertNode(treeT \*tptr,int key);  

```
#include<stdio.h>
#include<stdlib.h>

typedef struct nodeT{
	int key;				  //为了方便,定义了一个整型
	struct nodeT *left,*right;
	
}nodeT;
typedef nodeT *treeT;


treeT FindNode(treeT t,int key){
	int sign;
	
	if(t==NULL) return NULL;
	if(t->key > key){
		return(FindNode(t->left,key));		//递归查询
	}else if(t->key < key){
		return(FindNode(t->right,key));
	}else{
		return t;
	}
}

void InsertNode(treeT * tptr,int key){
	treeT t;
	t = *tptr; 
	if(t==NULL){
		t = (treeT)malloc(sizeof (nodeT));
		t->key = key;
		t->left = NULL;
		t->right = NULL;
		printf("%d\n",t->key);
		*tptr = t;
		return;
	} 
    
	if(t->key > key){
		printf("t->left:%d\n",&t->left);
		InsertNode(&t->left,key);
	}else {
		nodeT *tt = t->right;				//t的右子节点为空, 指向了 NULL
		printf("t:::::%d\n",tt);			//0
		printf("t->right:%d\n",&t->right);  //存储 t->right指针的  地址,可以改变地址的内容
		InsertNode(&t->right,key);			//从而创建子节点,使地址的值发生改变,使其值变为 
                                            //新创建的节点 的地址.地址内容发生改变
	}                                       //最好是画个图  把treeT t, nodeT , treeT *tptr 
                                            //互相指一下.方便理解  
	
	
}
void DisplayTree(treeT t){
	if(t!=NULL){
		DisplayTree(t->left);   			//递归调用
		printf("%d\n",t->key);
		DisplayTree(t->right);
	}
}
int main(){
	treeT tree=NULL;
	
	InsertNode(&tree,5);
	InsertNode(&tree,4);
	InsertNode(&tree,6);
	printf("print the tree\n");
	DisplayTree(tree);
	
	
	treeT tr = FindNode(tree,4);
	printf("%d\n",tr->key);		//5
	return 0;
}
```

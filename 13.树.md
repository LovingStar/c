##13.1树的定义
本章将介绍一种使用指针来模拟层次关系的数据结构---**树**,它是由一个具有一下特征的称为**节点**的项的集合所定义的:  
1. 只要树中有节点,必定有一个称为**根**的节点,它是最顶层.  
2. 其他节点通过唯一确定的下降路径链接到根.  
![image](https://github.com/nightriain/c/blob/master/tree.jpg)  
###13.1.1描述树的术语
如上图所示:
节点1 为 **根**  
节点 8 9 10 6 7,这些没有孩子的节点,称为 **叶**  
即不是根节点,也不是叶节点,称为**内部节点**,如 2 3  
节点2 和节点3 是节点1的**孩子**  
节点2 和节点3 是**兄弟**  
树的**高度**定义为,从根到叶的最长路径的长度,从1到8最远,树的高度是4.  
###13.1.2树的递归特性
从树中选取一个节点及其子孙构成的树称为原树的**子树**.  
树中的每个节点都可以看成是以它自己为根的 子树的根.  
###13.1.3用 C语言表示树  
结构体的定义:  
```
typedef struct familyNodeT{
    string name;
    struct familyNodeT *children[MaxChildren];  //包含了一个指向自身的指针数组
}familyNodeT,*familyTreeT;
```
 
##13.2二叉搜索树
树的一个最终要的子类是**二叉树**,具有如下特征:  
1. 树中的每个节点至多有两个孩子.  
2. 除了根以外的其他节点不是父节点的左孩子,就是右孩子.  
二叉树的节点所具有的几何关系使得使用二叉树来表示数据的有序集合十分方便.  
通常的应用使用一种称为**二叉搜索树**的特殊二叉树,它由以下特性定义:  
1. 每个节点包含(可能有其他数据)一个称为"键"的特殊值,该值定义了节点的顺序.  
2. 键具有**唯一性**,在树中键不能出现多于一次.  
3. 在树中的每一个节点,键值必须大于其子树中左孩子的所有键,小于子树中有孩子的所有键.  

简单来讲.一个树上的键不能有重复的值,和之前的符号表有些类似,相同的键只能存在一个.节点要大于它的左孩子,小于右孩子.  
###13.2.2在二叉搜索树中查找节点  
由于树是递归结构,很容以递归的形式对该搜索算法进行编码.  
InsertNode代码稍微有些复杂,难点是InsertNode必须能够通过增加一个新建来改变二叉搜索树的值.  
在C语言中,函数不能改变其参数的值,为了绕过这个限制,InsertNode必须使用引用调用,而不是像FindNode中那样接受一个treeT作为参数,InsertNode需要接收一个指向treeT的指针.因此它的原型如下:  
void InsertNode(treeT \*tptr,int key);  

本意是想 修改 right中的地址 指向新的节点 完成创建  
但是参数不能被修改 你直接传入 node\*类型(treeT) 无法修改 它所指的地址  
所以只好传入一个 node\*\*类型(treeT \*)来达到目的  

```
#include<stdio.h>
#include<stdlib.h>

typedef struct nodeT{
	int key;				  //为了方便,定义了一个整型
	struct nodeT *left,*right;
	
}nodeT;
typedef nodeT *treeT;


treeT FindNode(treeT t,int key){
	int sign;
	
	if(t==NULL) return NULL;
	if(t->key > key){
		return(FindNode(t->left,key));		//递归查询
	}else if(t->key < key){
		return(FindNode(t->right,key));
	}else{
		return t;
	}
}

void InsertNode(treeT * tptr,int key){
	treeT t;
	t = *tptr; 
	if(t==NULL){
		t = (treeT)malloc(sizeof (nodeT));
		t->key = key;
		t->left = NULL;
		t->right = NULL;
		printf("%d\n",t->key);
		*tptr = t;
		return;
	} 
    
	if(t->key > key){
		printf("t->left:%d\n",&t->left);
		InsertNode(&t->left,key);
	}else {
		nodeT *tt = t->right;				//t的右子节点为空, 指向了 NULL
		printf("t:::::%d\n",tt);			//0
		printf("t->right:%d\n",&t->right);  //存储 t->right指针的  地址,可以改变地址的内容
		InsertNode(&t->right,key);			//从而创建子节点,使地址的值发生改变,使其值变为 
                                            //新创建的节点 的地址.地址内容发生改变
	}                                       //最好是画个图  把treeT t, nodeT , treeT *tptr 
                                            //互相指一下.方便理解  
	
	
}
void DisplayTree(treeT t){
	if(t!=NULL){
		DisplayTree(t->left);   			//递归调用
		printf("%d\n",t->key);
		DisplayTree(t->right);
	}
}
int main(){
	treeT tree=NULL;
	
	InsertNode(&tree,5);
	InsertNode(&tree,4);
	InsertNode(&tree,6);
	printf("print the tree\n");
	DisplayTree(tree);
	
	
	treeT tr = FindNode(tree,4);
	printf("%d\n",tr->key);		//5
	return 0;
}
```
##13.3平衡树
如果在上面的代码中,按照 5,4,3,2,1的顺序插入节点,那么这棵树看起来会像一个链表一样.  
用来实现InserNode的二分搜索算法只有在每个节点的左子树和右子树大致具有相同高度时才能取的理想性能.  
具有这种特征的树,称为是**平衡**的,严格地说,如果每个节点的左子树和右子树的高度至多相差1,就称该二叉树是平衡的.  
###13.3.1树的平衡策略
扩展InsertNode函数的实现,使得它跟踪当插入新节点时树是否平衡.如果树变得不平衡,那么InsertNode必须重新排列树中的节点,使得在不破坏二叉搜索树要求的次序关系的情况下让树重新获得平衡.  
###13.3.2举例说明AVL的思想
创建一颗二叉搜索树,其中节点包括化学元素符号.开始的6个元素为:  
H,He,Li,Be,B,C  
为了跟踪树是否平衡,AVL算法将每个节点都关联一个整数,该整数表示的是**右子树高度减去左子树高度的值**.该值称为节点的  
**平衡因子**.
###13.3.3单旋转
AVL策略的基本思想是:总可以通过一次简单地节点重新排列来使树达到平衡.  
如果按照标准的插入算法加入Li,结果状态如下图所示:  
![image](https://github.com/nightriain/c/blob/master/Image/单旋转1.jpg)    
需要He节点向上移动称为树的根,而H向下称为He的孩子,从某种程度上讲这个转换具有将H和He向左旋转的特点  
旋转操作中锁设计的两个节点被称为旋转的**轴**,旋转操作是绕着H-He轴进行的,由于该操作向左移动节点,称为左旋转.  旋转后的结果如下图:  

![image](https://github.com/nightriain/c/blob/master/Image/单旋转2.jpg)    
  
如果树是在相反的方向上失去平衡,那么可以使用对称的操作,称为右旋转.对于接下来两个元素Be和B,每个元素都加在树左边.  
![image](https://github.com/nightriain/c/blob/master/Image/右旋转1.png)  
为了平衡,需要绕着Be-H执行一次右旋转.结果如下图:  
![image](https://github.com/nightriain/c/blob/master/Image/右旋转2.png)  

如果在当前树下加上C的话,树的状态如下图所示:  
![image](https://github.com/nightriain/c/blob/master/Image/右旋转3.png)  
根节点不平衡,使徒通过绕着Be - He轴向右旋转来获得平衡,得到如下图所示:  
![image](https://github.com/nightriain/c/blob/master/Image/右旋转4.png)  
然而旋转之后并没有什么卵用.. 树还是不平衡,唯一不同的是根节点现在在相反的方向上不平衡了.  
###13.3.4双旋转
最后这个例子中的问题出现是由于旋转所设计的节点的平衡因子(为了方便画图我没在图上标记,具体定义看上面)的符号相反,最初是-2,旋转后变为+2.当出现这种情况时,单旋转不能使树重新平衡.为了解决这个问题,需要进行两次旋转.  
**在不平衡的节点旋转前,需要将它的孩子沿相反的方向旋转.**对孩子的旋转使得双亲与孩子的平衡因子具有相同的符号,就可以成功地进行下一步旋转了,这样的操作对称为**双旋转**.旋转前:  
![image](https://github.com/nightriain/c/blob/master/Image/右旋转3.png)  
在加入符号C之后形成的平衡树.第一步是绕着Be-H轴向左旋转.旋转后:  
![image](https://github.com/nightriain/c/blob/master/Image/双旋转1.png)  
虽然得到的树的根节点仍旧是不平衡的,但是H和He节点现在的平衡因子同号,这时绕着H-He轴向右单旋转使树平衡.  
![image](https://github.com/nightriain/c/blob/master/Image/双旋转2.png)  

树平衡算法具有如下特征:  
1. 如果向AVL树中插入一个新节点,总可以通过执行至多一次操作来重新平衡,该操作是一个单旋转或是一个双旋转.  
2. 在执行完旋转操作后,旋转轴的子树的高度总是和旋转前一直.这个特性保证了不会改变任何树中更高层次的平衡因子.  
###13.3.5实现AVL算法



##15.1为数学抽象的集合
**集合**可以看成是一个对不同元素的无序收集.  
集合是无序的,如果以其他顺序写下相同名称的一个集合,这两个集合是相同的.但是,集合不能有**同一个元素**的多个副本.  
在星期中,所有天数的集合是一个**有限集合**.所有整数的集合是一个**无限集合**.  
###15.1.1成员资格
定义一个集合的基本特征是**成员资格**,在数学中,成员资格形式化用x∈S标记表示.表明:值x是集合S的一个元素.  
集合的成员资格通常可以通过下列方式之一指定:  
1. 枚举.通过枚举定义一个集合就是简单地列出集合中的元素.例如,集合**D**是一位数字的自然数.  
**D** = {0,1,2,3,4,5,6,7,8,9}  
2. 规则.通过指定区别集合的成员的规则来定义一个集合.规则分为两部分:提供潜在候选项的一个较大的集合的定义和那些元素应当被选取到结果中的一些条件表达式.如,前一个实例中的集合D可以定义为:  
**D** ={x|x∈N 且 x < 10}  
###15.1.2集合运算
并 两个集合的并,写为A∪B. 是所有属于集合A或集合B或两个集合的元素的集合.  
交 两个集合的交,写为AnB .既属于A又属于B的元素构成的集合.
集合差 两个集合的差 写为A-B,由属于A但不属于B的元素构成.  

检查特定性质的运算与数学中的断言函数等价,通常称为**关系**.集合最终要的关系如下:  
相等 如果集合A,B有相同的元素,则他们相等.  
子集 如果集合A包含集合B,称B是A的**子集**.如果集合A包含集合B,两个集合不相等.则称B是A的**真子集**.  
###15.1.3集合恒等式
A∪A = A. AnA= A 幂等式  
An(A∪B) = A. A∪(AnB) = A. 合并  
A∪B = B∪A. AnB = BnA.交换律  
A∪(B∪C) = (A∪B)∪c. An(BnC) = (AnB)nC 结合律
A-(B∪C) = (A-B)U(A-C).A-(BnC) = (A-B)n(A-C). 摩根律  
###15.2设计集合接口
应有如下操作:  
分配和释放 加入和删除元素 检查成员资格 确定元素数量 高级集合操作 迭代  
###15.2.1定义元素类型
集合包的用户分为两类,第一类的用户希望使用包含整数.或像整数一样行为的标量类型值(如char或用户自定义枚举类型)  
第二类希望使用其元素是抽象数据类型的集合.由于所有的标量类型都自动地转为整型,所有抽象数据类型都用指针表示.  
因此只需要考虑两种元素类型,int和 void\*.  
可采取策略如下:  
1. **根据允许用户修改的一个命名的元素类型定义接口**. 类似在 stack中一样.它要求用户通过编辑接口来修改元素类型,然而在实际中只可能出现两种元素类型,值得寻找一种不需要用户编辑接口内容的替代方法.  
2. **忽略整型集合,强制所有用户使用指针类型**.它根据最灵活的类型来定义这个接口.希望使用整型集合的用户可以通过动态分配创建指向整型的指针,然后将得到的指针存储在集合中.但是这种方法代价很大.希望使用整型集合的用户编程人员通常对效率有很高的要求,为存储在集合中的每个只分配新控件的好用必然将超出这个范围.  
3. **忽略一般的指针集合,强制所有用户都使用整型集合**.希望在集合中存储指针类型的用户编程人员可以通过将所有指针值存储在一个数组中,然后创建数组下标的集合来绕过这个限制.  
4. **定义一个允许用户存储整型或指针的联合类型**.导出一个联合类型会强加给所有用户额外的工作,因为它们必须声明联合类型的值并将它们自己的数值赋给内部合适的域.该方法没有提供用以实现获取存储在联合类型中的值的类型的简单方法.如果在联合类型中包含标记的方法来解决这个问题,那么会带来维护该标记的额外开销.  
5. **定义两个独立的接口,一个针对整型集合,另一个针对指针集合**.为整型定义intset.h.还有一个独立的接口ptrset.h,这种策略满足了多有用户的需求,看起来不错.但是存在两个类似但又是不同的接口对于接口设计中概念上的简单性和维护实现的开销都具有反面影响.  
6. **定义一个支持两类集合的单个接口**.被证明最好的方法是设计一个允许用户创建两种不同类型集合的单个接口(类似两个构造函数).  
  
集合的相关应用:  
在第14章的表达式语法分析器中,需要检查一个特定的字符是否是一个合法的运算符,可以使用该集合包来构建一个合法运算符的集合,然后使用相关函数判断所问的字符是否是该集合的成员.  
在输入字符串验证重复时,可以把输入的字符串加入到一个指针集合中,最后再遍历出来.  
##15.3实现集合包
集合包可以依赖二叉搜索树进行实现.集合中的检查成员资格和在二叉搜索树中查找一个节点类似.两种结构的插入和删除操作的行为也很类似,因为二叉搜索树中的键和集合中的元素一样,也是唯一的.  
下面的代码只是把集合的结构和相关初始化写出
```
//定义了集合的结构
struct setCDT{
  setClassT class;
  CmpFnT cmpFn;
  int nElements;
  bstADT bst;   //二叉搜索树
}
typedef union{
  int intRep;
  void*ptrRep;
}setElementT;   //基本单元

//两个构造函数,通过包装函数传递相关参数创建不同类型的集合
setADT NewIntSet(void){ 
  return (NewSet(IntSet,IntCmpFn));
}
setADT NewPtrSet(cmpFnT cmpFn){
  return (NewSet(PtrSet,cmpFn));
}
static setADT NewSet(setClassT class,cmpFnT cmpFn){
  setADT set;
  
  set = New(setADT);
  set->class = class;
  set->cmpFn = cmpFn;
  set->nElements = 0;
  set->bst = NewBST(sizeof(setElementT),cmpFn,InitSetNodeFn);
  return(set);
}

```
##15.4设计多态迭代器
让iterator.h接口多态,就是说用户可以是同它同意好地遍历符号表,集合或任何其他包含元素的类型中的元素.将这样的类型称为**聚集类型**.将一个抽象数据类型转化为一个聚集类型需要在该类型的视线中附加代码,但是不应当要求用户知道聚集类型自身内部结构的任何细节.  
###15.4.1泛化迭代器函数的原型
接口中定义三个迭代器函数接收一般化的void\*类型作为参数,那么用户编程人员仍可以很好的进行操作,这是原型:  
iteratorADT NewIterator(void * collection);  
bool StepIterator(iteratorADT iterator,void \*ep);  
void FreeIterator(iteratorADt iterator);  
这些函数没有一个指明聚集是一个setADT,symtabADT或是其他类型,也就意味着没有任何东西妨碍你对任意聚集类型调用这些函数.  
###15.4.2在迭代器实现中假如多态性
NewIterator的实现需要知道关于聚集类型的一些信息以便正确的进行初始化.  
对于在NewIterator原型中声明为void\*的聚集参数的匿名字符,NewIterator并不清楚如何初始化一个适合传入的聚集类型的迭代器.  
解决方法是: 保证任何聚集类型的底层数据结构包含一个指向创建新迭代器的回调函数的指针.因此,集合的内部数据结构应当包含一个创建集合的迭代器的函数的指针,而符号表的数据结构应当包含一个在符号表中执行相同操作的函数的指针.然而如果NewIterator代码想要调用该函数,那么函数指针必须总是在具体结构的预定义位置出现,通常的方法是将函数指针放置在一个头块中,这可以保证在聚集类型的最开始位置出现.如下图:  
![image](https://github.com/nightriain/c/blob/master/Image/迭代器多态图.jpg)  
当NewIterator获取参数时,可以设想该地址引用了一个迭代器头块并调用其中的函数指针.  
然而,如果用户试图对一个不包含所需的迭代器头的类型调用NewIterator时,假设没有人知道针对queueADT类型的迭代器的实现,如果对一个队列调用 NewIterator, 那么实现会很简单地假设,已经传递了一个合法的集合类型并将块开头的部分堪称是一个函数指针,这样很容易引起程序崩溃.  
通过为NewIterator代码建立运行时检查可以去的某种程度的安全性.最简单的方法是要求任何聚集类型的头域以不可能随机出现的特定位形式开始.用来避免非法 操作的特定位形式称为**密码**.当 创建了一个合法聚集类型的值时,构建函数在头部的开头存储正确的密码,然后,NewIterator的函数在调用函数前可以检查以判断密码是否恰当.  
```
代码暂时省略,有时间再补
```
##15.5提高整型集合的效率
只要限制集合的元素为某个预定义范围内的整数,还是有更高效的方法来表示整型集合.在很多应用中,集合自然遵守这个约束.例如,如果使用整型集合来表示字符集合,那么值永远不会超出[0,255]的范围.如果集合的元素类型是一个典型枚举类型,那么合法值的集合将被限制在一个更小的范围内.  
###15.5.1特征向量
假设正在操作一个其元素的值总是在0~ RangeSize-1之间的一个集合.其中RangeSize是一个值指定范围大小的常量,元素的值被限制在该范围之内.  
可以用一个 bool值的数组来表示这样一个集合. 比如3在集合中,那么ele[3]=true. 如果0不在集合中,ele[0]=false.  
其元素指明对应的下标是否为某个集合的成员的布尔数组称为**特征向量**.  
使用特征向量的优点是,可以恒定时间实现操作 添加 删除 检查.比如需要添加8到集合中,只需要 ele[8] = true.  
###15.5.2压缩的位数组
虽然特征向量运行时间上有高效的实现,但是将特征向量直接存储为数组需要很多的内存,特别是当RangeSize比较大时,为了减少内存的需求,可以将特征向量的元素压缩到机器字中,是表示利用底层表示中的每一个位.假设在你的机器中类型unsigned long 被表示为一个32位的值,那么可以在一个unsigned long类型的值中存储32个特征向量的元素,因为特征向量的每一个元素只需要一个位的信息.而且,如果RangeSize是256,那么可以将有256个表示特征向量需要的位存储到8个unsigned long的值的数组中.  
如下面这个集合,该集合由编码65~90的26个大写字母和编码97~122的26个小写字母构成.特征向量如下:  
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 (0)行  
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 (1)行  
0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 (2)行  
0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 (2)行
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 (4)行  
横左标  左边是31,最右边是0.  
###15.5.3位运算符
<table>
<tr><td>位运算符</td><td>描述</td></tr>
<tr><td>x & y</td><td>逻辑AND.x,y都为1,才是1</td></tr>
<tr><td>x | y</td><td>逻辑或,x,y只要有一个是1,就为1</td></tr>
<tr><td>x ^ y</td><td>异或,当x,y不相同时,为1</td></tr>
<tr><td>~x</td><td>取反.x为0, 结果是1</td></tr>
<tr><td>x << n </td><td>左移动,x左移n位</td></tr>
<tr><td>x >> n</td><td>右移动,x右移n位</td></tr>
</table>

##2.1枚举类型
通过在域中列出若干元素而定义出新的类型,这种类型称为 **枚举类型**.  
定义形式:  
**typedef enum** {_element_ - _list_} _name_;
其中,element - list是标识符的列表,称为枚举常量.name是这个新类型的名称.
例如:typeofdef enum{North,East,South,West}directionT;定义了罗盘上的四个主要方向.  
###2.1.1枚举类型的内部表示
枚举类型的值在机器内部当作整型来存储.默认从**0**开始,分配给枚举常量一系列整数.如果没有指定枚举常量值,编译器会在前一个常量值的基础上直接加1.直接输入字符串可以被识别转换成所对应数值.  
typedef int lz;lz类型也是int类型,可以用 lz n = 5;n是 lz类型的一个值,为5.  
##2.2数据和内存
###2.2.1位,字节,字  
**位**(bit)是二进制位(binary digit)的缩写.只有两种单位,0和1.  
一个**字节**有8位.单个的位连载一起组成一个独立的较大的存储单元.可以表示一个**字符**类型.  
**字节**联系在一起组成更大的结构称为**字**.  
###2.2.2内存地址
在内存系统中,每个字节都由一个数字**地址**所标识.  
sizeof查看给某一变量分配了多大的空间. sizeof(int);sizeof x;返回存储x所需的字节数  
##2.3指针
好处:  
1. 以一种简洁方式访问一个大的数据结构.不管数据结构多大,指针访问的是地址.可以节省存储空间.  
2. 在不同程序间的数据共享更方便. 传递的是地址,不同函数可以访问同一个数据.  
3. 在程序执行时流出内存空间.在运行时请求新的内存,可以用指针引用它们.  
4. 指针可以记录各数据项之间的关系.  
###2.3.1把地址当作数值
任何代表内存中能存储数据的内存单元的表达式都称为左值.这些标识符都出现在c中赋值语句的左边.  
左值特性:  
1. 任何一个左值都存储在内存中,都有地址.  
2. 一旦声明了一个左值,它的地址就不会改变,但地址中存储的内容经常改变.  
3. 声明的数据类型不同,左值占据的内存空间大小不同.  
4. 左值的地址是指针变量,可以存储在内存中,可以像数据那样操纵.  
###2.3.2声明指针变量
声明指针变量,在变量名称前加\*.例如:int \*p;声明p是一个指向int型的指针变量.  
###2.3.3基本的指针运算
\& 取地址,以左值为操作数,返回左值所在的内存地址.  
\* 取所指数据,取指针所指的值.返回一个左值.  
int x =2;  
int \*p;  
p=\&x;(p中存储的是x的内存地址)  
\*p;(2)
###2.3.4特殊指针NULL
NULL表示指针并不指向任何实际单元.访问值为NULL的指针的数据是没有意义的.  
##2.4数组
数组是单个数据的集合,特性:  
1.有序.  
2.数组中存储的每一个元素必须是同一个类型.  
C语言中数组有两个基本特性:  
1. 元素类型  
2. 数组大小
###2.4.1声明数组
格式: _type name[size]_  
必须给定数组的大小,size必须为常数.  
\#define NElements 10  
int arr[NElements];  
###2.4.2数组选择
选择表达式:_array[index]_  
###2.4.3分配的空间和利用的空间  
声明中指定的数组大小称为**分配空间**,实际使用的元素数量是**利用空间**.  
###2.4.4把数组作为参数
在参数名称的后面加上[],例如:double Mean(double array[],int x);  
数组自动传递引用.  
###2.4.5初始化数组
声明:  
int digits[5]={0,1,2,3,4};  
int digits[] = {0,1,2,3,4};  
sizeof digits 可以得到数组中的**元素数量**(返回字节数,20).  
###2.4.6多维数组
在二维数组中,第一个索引号叫行,第二个索引号交列.  
C语言要求在传递多维数组时必须给出**除第一个索引以外**的参数数组中每一个索引的大小.  
##2.5数组与指针
int arr[]={0,1,2,3};  
int \*p;  
p = arr;(把arr[0]的地址赋值给p)
p = &arr[0];  
p = p+1;(得到arr[1]的地址)  
指针不可以**加上**另一个指针,但可以加上一个整数.  
指针如果减去另一个指针,返回两个指针之间的数组元素的个数.  
##2.6记录
定义新的 结构类型形式:  
typedef struct{  
_field-declarations_  
} name;  
例如:  
typedef struct{  
  int birth;  
  int age;  
} boy;  
声明一个新的类型变量: boy b;  
选择某一项: b.age;  
**记录的指针**可以操作记录中的字段,在函数传递时,传递记录指针可以改变记录内部的字段的值.  
boy \*bp;  
bp = &b;  
bp->age = 18;即:(\*bp).age = 18;  
##2.7动态分配
1. 声明全局变量,编译器分配给全局变量内存空间,知道整个程序结束才收回内存,是**静态分配**.  
2. 在函数中声明局部变量,该变量在系统栈中分配空间,调用这个函数时为变量进行空间分配,函数结束后就收回分配的地址空间.称为**自动分配**.  
3. 在需要空间时显式地申请,不需要时显式的释放.这种模式称为**动态分配**.  
如果希望分配10个字节的内存,可以调用:  
malloc(10);  
指针是有类型的,malloc返回的是一个**没有类型**的通用指针.  
如果声明一个指向void的指针,可用:void \*vp;可以在该变量中存储任何类型的指针值.但是void类型的指针不可以使用\*运算符取的值,编译器不知道这种类型的指针的基础类型,所以指的数据也没有意义.  
可以进行相应的转换,例如:  
char \*cp;  
cp = malloc(10);  
if(cp==null) xxx;申请后加入相应判断,看是否申请成功.  
显式转换:  
cp = (char\*)malloc(10);  
**释放**:free(cp);  
**动态数组**  
cp = malloc(10);  
变量cp指向一个有10个连续字节的集合,这些控件位于内存的堆,这个指针变量可以当作一个有 10 个字符的数组.  
这种从堆中分配的,并有一个指针指向的数组称为**动态数组**.  
声明数组和动态数组的最根本区别:  
1. 声明的数组内存的配分作为声明的一部分,在声明时就完成;在动态数组中,只有当函数 malloc 被调用时才给元素分配空间.  
2. 声明的数组大小在程序数中必须是常熟. 因为动态数组的内存来自于堆,所以它可以是任意的大小.  
例如,定义一个动态数组darray,它有n个元素,类型是double.  
 double \*darray;  
 darray = malloc(n\* sizeof(double));  
 计算一个double的字节数,然后乘以相应数量,获得所需的空间大小.  
**动态记录**
 typedef struct{  
  int birth;  
  int age;  
} boy;  
boy \*bp;  
bp = malloc(sizeof(boy));  







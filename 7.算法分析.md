##7.1排序问题
###7.1.1选择排序法
思路: 遍历整个数组中每个元素的值,找到最小的那个,和第一个位置的元素交换.  
然后从第二个位置开始遍历整个数组,找到最小的元素,和第二个位置的元素交换,依此类推.  
有数组[5,10,4,3]  
第一次遍历,最小的为3,和第一个位置交换[3,10,4,5]  
第二次遍历,最小的为4,和第二个位置交换[3,4,10,5]  

```
void SortIntegerArray(int arr[],int n){
	int tag,temp;
	for(int i = 0;i < n;i++){
		tag = i;
		for(int j = i;j < n;j++){
			if(arr[j]<arr[tag]){
				tag = j;        //记录最小位置
			}
		}
		temp = arr[i];
		arr[i] = arr[tag];
		arr[tag] = temp;
	}
	
}
```
##7.2计算复杂度
描述计算机复杂度的符号,称为**大O符号**
简化标准:  
1. **删除随N值变大而对综合不再重要的项**.当公式由几个多项式相加而成,随着N的增大,其中一项增加速度比其他项快,最后该项在  
公式中占主导地位,对于较大的N值,该项可肚子控制算法的运行时间,因此可以忽略整个公式中的其他项.  
2. **删除所有常数因子**. 比如O(2N) 就变为 O(N)  
###7.2.4根据代码结构预测复杂度
代码的某些部分只执行一次,不受数据的有效规模的影响的执行时是**固定时间**. 比如 total = 1;该执行时间用大O符号表示为  O(1).  
for循环的循环体,执行了n次,正比于数组的规模,复杂度是O(N).  
嵌套了两个for循环,两次循环都由N的值决定,外循环执行一次,内循环执行n次, 也就暗示内循环执行O(N^2)次.  
像选择排序这样的O(N^2)次的算法称为以**平方时间**运行.  

##7.3递归帮助
###7.3.1分治策略
二次方复杂性(O(N^2))的基本特点是:如果问题规模翻倍,运行时间则变为四倍.然而反过来,如果把问题规模除以2,运行时间降低为运行时间除以4.  
这种事实暗示着把数组一分为二,并且用递归的分治法可以缩短排序时间.  
###7.3.3合并排序算法
**在函数中创建新数组要使用malloc创建**  
基本思想:  
1. 检查数组为空或是否仅有一个元素.如果是,那么它一定是已排序的,函数不再做任何工作,这是递归的最简单情景.  
2. 把该数组分解为两个子数组,每个新数组都是原数组长度的一半.  
3. 递归地为这两个数组排序.  
4. 把两个子数组合并为一个.  
```
代码暂时省略 有相应JS代码
```

##7.5快速排序
基本思想:  
1. 选一个元素作为小元素和大元素的分界线,该元素常称为**枢轴**.可以是任意一个元素.  
2. 重排数组中的元素,把比枢轴大的元素放右边,比枢轴小的元素放左边.  
3. 为每一个子数组元素排序.枢轴把一个数组分成两份,左边比它小,右边比它大,对这两个数组进行快速排序.  
```
代码暂时省略 有相应JS代码
```
##总结
1. 通过观察算法所包含的循环嵌套结构,可以预测算法的计算复杂度.  
2. 两个有用的复杂度指标是最坏情况分析和平均情况分析.平均情况分析通常更难处理,最坏情况分析是,在最坏的情况下需要的时间.   
3. 分治策略可以使选择排序的复杂度从O(N^2) 减为O(Nlog(N)).  
4. 常见的复杂度类型包括 常数类,对数类,线性类, Nlog(N)类,平方类,立方类和指数类.当问题规模足够大时, 在复杂度类型表中先出现的类型所对应的算法比后出现类型所对应的算法效率高.  
5. 快速排序在实践中表现得很好,虽然它的最坏情况复杂性是O(N^2);  

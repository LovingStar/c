##7.1排序问题
###7.1.1选择排序法
思路: 遍历整个数组中每个元素的值,找到最小的那个,和第一个位置的元素交换.  
然后从第二个位置开始遍历整个数组,找到最小的元素,和第二个位置的元素交换,依此类推.  
有数组[5,10,4,3]  
第一次遍历,最小的为3,和第一个位置交换[3,10,4,5]  
第二次遍历,最小的为4,和第二个位置交换[3,4,10,5]  

```
void SortIntegerArray(int arr[],int n){
	int tag,temp;
	for(int i = 0;i < n;i++){
		tag = i;
		for(int j = i;j < n;j++){
			if(arr[j]<arr[tag]){
				tag = j;        //记录最小位置
			}
		}
		temp = arr[i];
		arr[i] = arr[tag];
		arr[tag] = temp;
	}
	
}
```
##7.2计算复杂度
描述计算机复杂度的符号,称为**大O符号**
简化标准:  
1. **删除随N值变大而对综合不再重要的项**.当公式由几个多项式相加而成,随着N的增大,其中一项增加速度比其他项快,最后该项在  
公式中占主导地位,对于较大的N值,该项可肚子控制算法的运行时间,因此可以忽略整个公式中的其他项.  
2. **删除所有常数因子**. 比如O(2N) 就变为 O(N)  
###7.2.4根据代码结构预测复杂度
代码的某些部分只执行一次,不受数据的有效规模的影响的执行时是**固定时间**. 比如 total = 1;该执行时间用大O符号表示为  O(1).  
for循环的循环体,执行了n次,正比于数组的规模,复杂度是O(N).  
嵌套了两个for循环,两次循环都由N的值决定,外循环执行一次,内循环执行n次, 也就暗示内循环执行O(N^2)次.  
像选择排序这样的O(N^2)次的算法称为以**平方时间**运行.  

##7.3递归帮助
###7.3.1分治策略
二次方复杂性(O(N^2))的基本特点是:如果问题规模翻倍,运行时间则变为四倍.然而反过来,如果把问题规模除以2,运行时间降低为运行时间除以4.  
这种事实暗示着把数组一分为二,并且用递归的分治法可以缩短排序时间.  
###7.3.3合并排序算法
**在函数中创建新数组要使用malloc创建**
基本思想:  
1. 检查数组为空或是否仅有一个元素.如果是,那么它一定是已排序的,函数不再做任何工作,这是递归的最简单情景.  
2. 把该数组分解为两个子数组,每个新数组都是原数组长度的一半.  
3. 递归地为这两个数组排序.  
4. 把两个子数组合并为一个.  
```

```



##8.1栈
栈,存储在栈中的数据叫做元素,将一个新元素加入栈中称为**入栈**,从栈 中删除元素交**出栈**.遵循**后进先出**原则.  
###8.1.3栈和袖珍计算器
以**反向波兰表示法**的方式输入表达式的计算器.  
在反向波兰表示法表达式中,运算符在它的操作数后键入.例如:  
50 \* 1.5 + 3.8 / 2.0  
可以按照如下顺序键入  
50.0 [enter] 1.5 \* 3.8 [enter] 2.0 / +  
当按入enter时,计算器取前边的一个值并将其压入栈中.当键入运算符时,计算器首先检查用户是否刚键入了一个值,如果是,自动把它压入栈中.然后按照一下的操作步骤计算结果:  
1. 从栈顶弹出两个操作数.  
2. 将两个值依按钮的运算符进行计算.  
3. 将结果压回到栈中.  
##8.2定义栈的ADT  
###8.2.1定义栈抽象的类型
把相同函数应用到不同类型对象的能力称为**多态性**.  
如果在stack.h接口中定义void\*作为值的类型,那么需要才去如下的策略向栈中压入一个double类型的值:  
1. 用malloc为double类型的值分配空间.  
2. 将要压入的值赋给刚分配的内存.  
3. 将为double类型刚分配的地址压入到栈中.  
类型double的地址是一个有效的指针, 因此与在栈抽象中锁使用的void\*类型兼容.  
如果允许客户访问栈程序包中的源代码.  
可以使用 typedef double tackElementT  
可以根据类型不同,修改源代码,达到目的.  
###8.2.2不透明类型
在C语言中,可以在接口中定义一个类型,以便它的底层表示对客户实现隐藏.由于客户不可能看到抽象类型的底层表示,因此这种类型称为**不透明**.  
接口中的不透明类型隐藏了数据类型的表示细节, 正如函数原型隐藏了它们的底层实现一样.  
typedef struct stackCDT\* stackADT;  
该行代码将类型stackADT定义为一个指向 stackCDT结构的指针,其中stackCDT没有进行定义.  
由于指针具有相同的大小,即使在不知道数据结构本身细节情况下.编译器都允许处理器指向结构的指针.在ANSI C中,还没有定义的结构称为**不完全类型**.  
在该实现时,通过编写如下的实际的结构定义来完成这种类型:  
struct _nameCDT{  
   field declarations  
}_;  
这两个定义由称为**结构标记**的标识符 nameCDT链接起来.接口中的抽象定义表明:  
nameADT类型指向标记名为nameCDT的结构.接口的客户只能看到这些抽象类型.  
**CDT**是具体的类型,**ADT**是相应类型的**指针**.操作指针可以直接操作所指结构体所在的内存.  
###8.2.3 定义stack.h接口
函数原型应包括:  
```
创建一个新栈  stackADT NewStack(void);  
释放一个栈    void FreeStack(stackADT stack);  
加入一个元素  void Push(stackADT stack,stackElement element);  
弹出栈顶元素  stackElement Pop(stackADT stack);  
栈包含元素数  int StackDepth(stackADT stack);  
栈是否满      bool StackIsEmpty(stackADT stack);   //bool 是自定义类型  也是int  
栈是否空      bool StackIsFull(stackADT stack); 
得到一个元素  stackElement GetStackElement(stackADT stack,int index);
```
来一波代码  
```
//加入了部分验证
#include<stdio.h>
#include<stdlib.h>

#define MaxStackSize 33
typedef int stackElement;

struct stackCDT{
	stackElement elements[MaxStackSize];
	int count;
};
typedef struct stackCDT* stackADT;
//函数原型
stackADT NewStack(void);
void FreeStack(stackADT stack);  
void Push(stackADT stack,stackElement element);
stackElement Pop(stackADT stack);
int StackDepth(stackADT stack);
bool StackIsEmpty(stackADT stack);
bool StackIsFull(stackADT stack);
stackElement GetStackElement(stackADT stack,int index);
//函数实现
//创建栈
stackADT NewStack(){
	stackADT stack;
	stack = (stackCDT*)malloc(sizeof(stackCDT));
	stack->count = 0;
	return stack; 
}
//释放栈
void FreeStack(stackADT stack){
	free(stack);
	stack = NULL;
}
//检查空
bool StackIsEmpty(stackADT stack){
	return (stack->count == 0);
}
//检查满
bool StackIsFull(stackADT stack){
	return (stack->count >MaxStackSize);
}
//压入
void Push(stackADT stack,stackElement element){
	if(!StackIsFull(stack)){
		stack->elements[stack->count] = element;
		stack->count++;
	}else{
		printf("The stack is full!!!\n");
	}
}
//弹出
stackElement Pop(stackADT stack){
	if(!StackIsEmpty(stack)){
		stack->count--;
		int result = stack->elements[stack->count];
		return result;
	}else{
		printf("The stack is empty!!");
		stackElement s;
		return s;
	}
}
//检查存了多少个数
int StackDepth(stackADT stack){
	return stack->count;
}
//从0开始, 按照栈的顺序获取
stackElement GetStackElement(stackADT stack,int index){
	stackElement r;
	int length =stack->count;
	if(index>=length){
		printf("The index is out of range,please try again");
		return r;
	}else{
		return stack->elements[length - index - 1];
	}
}

int main(){
	 
	stackADT stack = NewStack();
	Push(stack,1);
	Push(stack,2);
	Push(stack,3);
	int test = GetStackElement(stack,0);
	printf("%d\n",test);
	
	while(!StackIsEmpty(stack)){
		printf("%d\n",Pop(stack));
	}
	return 0;
}
```
###8.4.3不透明类型的优点
比如定义的 StackDepth函数, 可以不使用,而是用stack->count.  
然而引入这个库的人员并不需要知道底层是如何实现,他只需要看说明文档,知道使用StackDepth(stack)就可以获得存了多少个数.  
不需要知道底层是如何实现,从而count对于他来说也是隐藏的.  
##8.5 定义一个 scannerADT
扫描器的抽象,它将一个字符串分解为**标记**,这些标记的定义是下列之一:  
1. 一连串数值字母字符(字母或是数字).  
2. 由空格或标点符号构成的单个字符的字符串.  

